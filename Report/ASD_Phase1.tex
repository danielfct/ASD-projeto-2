\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{booktabs}
\graphicspath{ {images/} }
\usepackage[portuguese]{babel}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{interval}

\begin{document}
\begin{titlepage}
    \includegraphics[width=0.3\textwidth]{fctUnlLogo.jpg}
    \begin{center}
        \vspace{0.5cm}

        \begin{Large}
        	\underline{\textbf{Publish-Subscribe on top of Chord}}\\
        \end{Large}
        
        \textbf{\emph{Opção A: Publish-Subscribe utilizando redes estruturadas}}
               
        \vspace{0.3cm}

		\includegraphics[width=0.35\textwidth]{Chord_network.png}
		
        \vspace{0.3cm}
        
        Trabalho realizado por:
        
        \vspace{0.5cm}

		\begin{table}[htbp]
		\centering
        	\begin{tabular}{c c}
				\textbf{Luís Duarte Oliveira, nº 41894} & \textbf{Daniel Pimenta, nº 45404}\\
				\texttt{ld.oliveira@campus.fct.unl.pt} & \texttt{d.pimenta@campus.fct.unl.pt}\\
			\end{tabular}
		\end{table}
		
		\begin{table}[htbp]
		\centering
        	\begin{tabular}{c}
				\textbf{Luís Martins, nº 45640}\\
				\texttt{lg.martins@campus.fct.unl.pt}\\
			\end{tabular}
		\end{table}
		
        \vspace{0.5cm}
        
        Para a cadeira de:
        
        Algoritmos e Sistemas Distribuídos (ASD)
        
        \vspace{0.5cm}

		Professor regente: 
		João Leitão
		
		Professor responsável:
		Nuno Preguiça
		
        \vspace{0.5cm}
                
        Departamento de Informática\\
        Faculdade de Ciências e Tecnologia\\
        Universidade Nova de Lisboa\\
        17 de novembro de 2018
    \end{center}
\end{titlepage}

\newpage
\tableofcontents

\newpage
\listoffigures

\newpage
\section{Introdução}

No âmbito da cadeira de Algoritmos e Sistemas Distribuídos, foi-nos proposto o projeto de implementar um sistema de \emph{Publish-Subscribe}, em cima de uma \emph{distributed hash table} (DHT).

DHT é um modelo de rede estruturada, com capacidade para guardar dados de forma distribuída, em cada nó da mesma.

Na implementação deste sistema, constatamos a complexidade desta classe de algoritmos.

Ao realizar testes sobre uma rede deste tipo, aprendemos a identificar as propriedades do sistema.

\newpage
\section{Visão global}

Este sistema pode ser decomposto em 3 camadas.

A primeira, é a camada que dá suporte ao sistema e que implementa a versão do Chord concorrente e tolerante a falhas \cite{b2}. Cada nó do sistema corresponde a um elemento do mesmo, pelo que terá as operações de criar, juntar, encontrar sucessor, publicar, subscrever, remover subscrição e enviar mensagem, entre outras que garantem a estabilização da rede em cada nó.

A segunda, é a camada relacionada com o sistema de \emph{Publish-Subscribe}. Esta, é responsável pela criação e subscrição dos respetivos tópicos de interesse, a cada individuo na rede. Com estas subscrições, será possível a troca de mensagens dentro de cada tópico.

A terceira e última, é a camada de teste. Esta, é responsável pela recolha e processamento dos dados de teste para futura análise.

As primeiras duas camadas, foram implementadas tendo como guia os materiais da cadeira de ASD \cite{b1}.

A implementação deste sistema, foi feito com a linguagem computacional de Scala \cite{b3}, utilizando o conjunto de ferramentas do Akka \cite{b4}.

\newpage
\section{Visão global detalhada}

Nesta secção, iremos explicar por escrito, em pormenor, os detalhes de cada uma das camadas anteriormente mencionadas.

\subsection{Chord}

Cada nó corre uma instância do Chord, permitindo assim todos os nós, terem acesso as ferramentas necessárias para a autogestão da rede.

Para criar um novo nó, o qual se chama a operação \emph{AddNode}, o nó preenche a sua \emph{fingers table}, com referências para si mesmo. Inicia os \emph{schedulers} necessários no Chord e no \emph{Publish-Subscribe}, os quais são: estabilização, correção de \emph{fingers}, verificar se o predecessor está ativo, enviar mensagens periodicamente de \emph{keepAlive}, fazer \emph{refresh} das suas subscrições e verificar o TTL dos seus subscritores.

Na adição do nó, poderão existir dois casos distintos: ou se trata do primeiro nó da rede, ou outro qualquer. No 1º caso, a operação termina aqui. No 2º caso, é fornecido um \emph{contact} node no momento da adição e quando esta termina, invoca a operação de find \emph{successor} no \emph{contact} node, passando o novo nó como argumento.

O \emph{contact} node, ao receber o pedido, invoca o seu find \emph{successor} local e envia o resultado para o nó emissor, que ao recebê-lo, vai atualizar a primeira entrada da sua \emph{fingers} table.

As restantes operações do algoritmo, correspondem à estabilização, notificação, correção da \emph{fingers} table e verificação do predecessor, correndo cada uma periodicamente numa \emph{thread} diferente.

Seguem-se os detalhes de implementação:

Estabilização - se existir uma referência válida, na primeira posição da \emph{fingers} table (sucessor), é pedido a esse nó, o seu predecessor. Ao obtê-lo, verifica se o nó é válido e se o id recebido, está no intervalo aberto, entre o seu id e o do seu sucessor. Se esta condição se verificar, atualiza a primeira posição da \emph{fingers} table, para o nó obtido. Independentemente da verificação da condição, a estabilização, chama sempre a operação de notificação do seu sucessor, por forma a notificá-lo da sua existência.

Notificação - Ao receber uma notificação, o nó verifica, se o nó recebido como argumento, é válido e se o predecessor é nulo, ou se o id do nó recebido, está contido no intervalo aberto, entre o predecessor e o seu id. Se esta condução se verificar, então atualiza o predecessor, com o nó recebido.

Correção da \emph{fingers} table - Existe uma variável global "\emph{nextFinger}", que indica a próxima posição da \emph{fingers} table a atualizar, garantido sempre, que esta variável não é superior ao tamanho da tabela. Em cada iteração desta operação, é  atualizada a posição "\emph{nextFinger}" da \emph{fingers} table, sendo o novo valor, o resultado da execução local de find\_successor(id do nó + $2^{nextFinger}$ mod tamanho do anel).

Verificação do predecessor - Esta operação é dividida em dois passos, \emph{KeepAlive} e verificação do TTL do predecessor. Periodicamente o nó, envia uma mensagem de \emph{keepAlive} ao predecessor e sempre que este responde, atualiza-se o TTL.  Ao mesmo tempo, corre uma operação que verifica a validade do TTL. Caso o TTL não seja válido, o predecessor é colocado a nulo.

A implementação do algoritmo, seguiu o pseudo-código do paper \cite{b2}, tendo-se substituído a invocação global de operações em nós, por envio de mensagens.

\newpage
\subsection{Publish-Subscribe}

Uma mensagem deste algoritmo, corresponde a um tópico, a um tipo de mensagem (\emph{PUBLISH}, \emph{SUBSCRIBE}, \emph{UNSUBSCRIBE}), a um texto e ao emissor original. Este algoritmo, utiliza a camada do Chord, para enviar as suas mensagens, tendo que para isso de calcular o \emph{hash} do tópico da mensagem, que vai ser usado pelo Chord,  para decidir o destino final.

Assim, existem 4 operações fundamentais:

\begin{itemize}
\item Operação de entrega de mensagem (\emph{deliver}) - Quando um nó recebe uma mensagem que lhe é destinada, efetua um processamento que varia consoante o tipo da mensagem:
\begin{itemize}
\item \emph{SUBSCRIBE} - adiciona o nó que pretende efetuar a subscrição (emissor original) ao seu mapa, cuja chave é o tópico e o valor é outro mapa. Este 2º mapa, que tem como chave o id do subscritor e como valor a respetiva referência. O \emph{SUBSCRIBE}, atualiza também o TTL do subscritor noutro mapa semelhante e adiciona a mensagem de subscrição, à lista de mensagens de subscrição enviadas.
\item \emph{UNSUBSCRIBE} - remove do mapa o nó, que pretende tirar a sua subscrição do tópico, o TTL e a mensagem de subscrição, presente na lista de mensagens de subscrição enviadas.
\item \emph{PUBLISH} - obtém o conjunto de valores do mapa, obtido do mapa de subscritores por tópico e envia para cada um, uma mensagem com o texto publicado (\emph{messageDelivery})
\end{itemize}
\item Operação de receber texto da mensagem (\emph{messageDelivery}) - corresponde ao nó, receber um texto publicado no tópico que subscreveu e é usado apenas para transmitir essa informação ao componente de testes.
\item \emph{Refresh} das subscrições - Esta ocorre periodicamente. Envia novamente todas mensagens de subscrição presentes na sua lista.
\item Verificar o TTL dos subscritores dos seus tópicos - Esta ocorre periodicamente. Obtém todos os subscritores de todos os seus tópicos e para cada um, vai verificar se a última mensagem de subscrição recebida + TTL, é inferior à hora atual. Se a condição não se verificar, remove a subscrição e o TTL associados, dos seus mapas.
\end{itemize}

\newpage
\subsection{Aplicação de teste}

O componente de testes, armazena o número de mensagens trocadas, (consideramos aqui todas as mensagens de find\_successor efetuados e \emph{addNodes} efetuadas), assim como o número de nós falhados, número de subscrições feitas, número de subscrições bem sucedidas, número de publicações, número de publicações bem sucedidas e nós corretos do sistema.

Possuí também uma lista de 50 tópicos e 5 mensagens que podem ser enviadas.

Os testes iniciam-se com um período de criação de nós, (criando o ator e enviando uma mensagem \emph{CreateRing}), guardando-se as suas referências num mapa de <id,ref> e garantindo sempre, que não existem nós com ids iguais. Para cada nó criado, é invocada a operação \emph{watch} do Akka, por forma a ser possível saber quando esta falha.

Após este período, aguardam-se alguns segundos, para que a rede fique estável e de seguida, inicia-se um período de subscrições, onde cada nó do sistema, vai fazer 5 subscrições em 5 tópicos aleatórios. À medida que as subscrições vão sendo efetuadas, é adicionado o id do nó, a um mapa que armazena os subscritores de cada tópico e permite obter o número de publicações esperadas. É também atualizado um mapa que indica, para cada tópico, qual o estado atual dos seus subscritores, (se apenas enviaram a subscrição, se já receberam a confirmação ou quantas publicações foram recebidas) e que permite saber o número de subscrições pedidas, confirmadas e número de publicações efetivamente recebidas.

O próximo passo, é um período de publicações, com tantas iterações quanto as pretendidas e que a cada 2 segundos, envia uma publicação com uma mensagem e tópico aleatórios, para um nó aleatório. Quando um nó recebe uma mensagem de texto, assinala ao \emph{tester}, o id da mensagem e tópico, para que este incremente a entrada corresponde ao tópico, no mapa que permite saber, o número de publicações efetivamente recebidas.

Quando todas as publicações tiverem sido enviadas, são esperados alguns segundos e depois o \emph{tester} apresenta uma mensagem, com a estatística da execução do algoritmo.

\newpage
\section{Pseudo-código e arquitetura}

Nesta secção, apresenta-se o pseudo-código e uma discussão sobre as propriedades de cada camada do sistema.

\subsection{Chord}

\subsubsection{Pseudo-Código}

O pseudo-código do Chord, segue rigorosamente o algoritmo apresentado pelo professor, nos slides da cadeira de ASD \cite{b1}.

\bigbreak
\textbf{State:}

\qquad ringSize; // tamanho máximo do anel

\qquad m; // tamanho da fingerTable, é o nº de bits do id máximo permitido

\qquad fingerTable; // tabela de tamanho m para permitir contactar nós mais afastados no anel

\qquad nextFinger; // próxima entrada da fingerTable para atualizar

\qquad predecessor; // nó anterior no anel

\qquad predecessorTTL; // tempo máximo de vida do predecessor, atualizado através de um processo keepAlive

\qquad TTL; // tempo de vida do predecessor em milisegundos

\qquad self; // informação sobre o próprio nó

\bigbreak
\textbf{Upon Init do:}

\qquad ringSize $\leftarrow$ N;

\qquad m $\leftarrow \max(3, \dfrac{\log ringSize}{\log 2})$;

\qquad fingerTable $\leftarrow$ \{\};

\qquad nextFinger $\leftarrow$ 1;

\qquad predecessor $\leftarrow \bot$;

\qquad predecessorTTL $\leftarrow$ 0;

\qquad TTL $\leftarrow$ 15000;

\qquad self $\leftarrow \bot$;

\bigbreak

\textbf{Procedure ClosestPrecedingFinger(id)}

\qquad \textbf{For} i $\leftarrow$ m - 1 to 0 \textbf{do:}

\qquad \qquad \textbf{If} fingerTable(i).id $\in \interval[open]{self.id}{id}$ \textbf{Then}

\qquad \qquad \qquad \textbf{Return} fingerTable(i);

\qquad \textbf{Return} self;

\bigbreak
\textbf{Upon AddNode}(id, contactNode) \textbf{do:}

\qquad self $\leftarrow$ (id, SELF);

\qquad \textbf{For} i $\leftarrow$ 0 until m \textbf{do:}

\qquad \qquad fingerTable(i) $\leftarrow$ self;

\qquad \textbf{Setup Periodic Timer Stabilize(T1)};

\qquad \textbf{Setup Periodic Timer FixFingers(T2)};

\qquad \textbf{Setup Periodic Timer CheckPredecessor(T3)};

\qquad \textbf{Setup Periodic Timer KeepAlive(T4)};

\qquad \textbf{Trigger Send(FindSuccessor}, contactNode, self.id, self.node, \_);



\bigbreak
\textbf{Upon Recieve(FindSuccessor}, sender, id, node, message) \textbf{do:}

\qquad \textbf{If} id $\in \interval[open left]{self.id}{fingerTable(0).id}$ \textbf{Then}

\qquad \qquad \textbf{If} message == $\bot$ \textbf{Then}

\qquad \qquad \qquad \textbf{Trigger Send(FoundSuccessor}, node, fingerTable(0));

\qquad \qquad \textbf{Else}

\qquad \qquad \qquad \textbf{Trigger Send(Deliver}, fingerTable(0).node, message);

\qquad \textbf{Else}

\qquad \qquad n $\leftarrow$ closestPrecedingNode(id);

\qquad \qquad \textbf{Trigger Send(FindSuccessor}, n, id, node, message);


\bigbreak
\textbf{Upon Recieve(FoundSuccessor}, successor) \textbf{do:}

\qquad fingerTable(0) $\leftarrow$ successor;

\bigbreak
\textbf{Upon Stabilize do:}

\qquad \textbf{Trigger Send(AskPredecessor}, fingerTable(0).node);


\bigbreak
\textbf{Upon Receive(AskPredecessor}, sender) \textbf{do:}

\qquad \textbf{Trigger Send(SendPredecessor}, sender, predecessor);

\bigbreak
\textbf{Upon Receive(SendPredecessor}, sender, newSuccessor) \textbf{do:}

\qquad \textbf{If} newSuccessor != $\bot$ $\wedge$ newSuccessor.id $\in \interval[open]{self.id}{fingerTable(0).id}$ \textbf{Then}

\qquad \qquad fingerTable(0) $\leftarrow$ newSuccessor;

\qquad \textbf{If} fingerTable(0) != self \textbf{Then}

\qquad \qquad \textbf{Trigger Send(Notification}, sender, self);

\bigbreak
\textbf{Upon Receive(Notification}, sender, node) \textbf{do:}

\qquad \textbf{If} predecessor == $\bot$ || node.id $\in \interval[open]{predecessor.id}{self.id}$ \textbf{Then}

\qquad \qquad predecessor $\leftarrow$ node


\bigbreak
\textbf{Upon FixFingers do:}

\qquad id $\leftarrow$ (self.id + $2^{nextFinger}) \mod{ringSize}$;

\qquad \textbf{Trigger Send(FindFingerSuccessor}, self, nextFinger, id, self);
 
\qquad nextFinger $\leftarrow \max(1, (nextFinger + 1) \mod{m})$;

\bigbreak
\textbf{Upon Receive(FindFingerSuccessor}, sender, index, id, originalSender) \textbf{do:}

\qquad \textbf{If} node.id $\in \interval[open left]{self.id}{fingerTable(0).id}$ 
\textbf{Then}

\qquad \qquad \textbf{Trigger Send(FoundFingerSuccessor}, originalSender, index, fingerTable(0));

\qquad \textbf{Else}

\qquad \qquad n $\leftarrow$ closestPrecedingNode(id);

\qquad \qquad \textbf{Trigger Send(FindFingerSuccessor}(n, index, id, originalSender);


\bigbreak
\textbf{Upon Receive(FoundFingerSuccessor}, sender, index, node) \textbf{do:}

\qquad fingerTable(index) $\leftarrow$ node;

\bigbreak
\textbf{Upon CheckPredecessor do:}

\qquad \textbf{If} currentSystemTime() > predecessorTTL \textbf{Then}

\qquad \qquad predecessor $\leftarrow \bot$;

\bigbreak
\textbf{Upon KeepAlive do:}

\qquad \textbf{If} predecessor != $\bot$ \textbf{Then}

\qquad \qquad \textbf{Trigger Send(KeepAliveSignal}, predecessor.node);

\bigbreak
\textbf{Upon Receive(KeepAliveSignal}, sender) \textbf{do:}

\qquad \textbf{Trigger Send(KeepAliveReply}, sender);

\bigbreak
\textbf{Upon Receive(KeepAliveReply}, sender) \textbf{do:}

\qquad predecessorTTL $\leftarrow$ currentSystemTime() + TTL;


\subsubsection{Discussão}

O Chord por se tratar de um sistema distribuído estruturado, consegue providenciar uma alta eficiência em determinados tipos de aplicações, como por exemplo, aplicações de \emph{routing}, ou de procura exata. No entanto, é mais sensível a falhas, devido a forma como os nós se ligam e é muito mais complexo de implementar, do que uma rede de sistema não estruturado.

Este algoritmo, tem o seguinte conjunto de propriedade:

\begin{itemize}
\item Validade - Se um processo correto i, envia uma mensagem m, então i, eventualmente entrega a mensagem. A estrutura em anel, garante que existe uma ligação entre os vários processos/nós, que fazem ligação entre si, o que garante que uma mensagem é entregue, mesmo que tenha de percorrer todo o anel.
\item Não Duplicação - Nenhuma mensagem é entregue mais de uma vez. O processo de envio de mensagens funciona por encaminhamento, desta forma não existe duplicação de mensagens.
\item Não Criação - Se um processo correto j, entrega uma mensagem m, então m, foi enviada por j, por um processo i. Apenas são entregues as mensagens originalmente enviadas, nunca são criadas mensagens novas durante o processo de envio, funciona apenas como um encaminhamento.
\end{itemize}

\newpage
\subsection{Publish-Subscribe}

\subsubsection{Pseudo-Código}

Nesta secção apresenta-se o pseudo-código do \emph{Publish-Subscribe}.

\bigbreak
\textbf{State:}

\qquad topicsWithSubscriptions; // mapa com todos os subscritores dos tópicos

\qquad subscriptionsAlreadySent; // lista com as subscrições enviadas

\qquad subscriptionsTTL; // mapa com o tempo máximo de vida das subscrições

\bigbreak
\textbf{Upon Init do:}

\qquad topicsWithSubscriptions $\leftarrow$ \{\};

\qquad subscriptionsAlreadySent $\leftarrow$ \{\};

\qquad subscriptionsTTL $\leftarrow$ \{\};

\qquad \textbf{Setup Periodic Timer RefreshMySubscriptions (T1)};

\qquad \textbf{Setup Periodic Timer CheckMyTopicsSubscribersTTL (T2)};

\bigbreak
\textbf{Procedure intSHA1Hash}(topic)

\qquad \textbf{Return} $\lvert SHA1.digest(topic) \mod{ringSize}\rvert$;

\bigbreak
\textbf{Upon SendMessage}(topic, msgType, msg) \textbf{do:}

\qquad m $\leftarrow$ (topic, msgType, msg, self);

\qquad \textbf{If} msgType == SUBSCRIBE \textbf{Then}

\qquad \qquad subscriptionsAlreadySent $\leftarrow$ subscriptionsAlreadySent $\cup$  \{m\};

\qquad \textbf{Else If} msgType == UNSUBSCRIBE \textbf{Then}

\qquad \qquad subscriptionsAlreadySent $\leftarrow$ subscriptionsAlreadySent $\setminus$ \{m\};

\qquad topicId $\leftarrow$ intSHA1Hash(topic);

\qquad \textbf{Trigger Send(FindSuccessor}, self, topicId, self, m);

\bigbreak
\textbf{Upon Deliver}(id, message) \textbf{do:}

\qquad (topic, msgType, msg, originalNode) $\leftarrow$ message;

\qquad \textbf{If} msgType == SUBSCRIBE \textbf{Then}

\qquad \qquad topicSubscribers $\leftarrow$ topicsWithSubscriptions[topic];

\qquad \qquad topicSubscribersTTL $\leftarrow$ subscriptionsTTL[topic];

\qquad \qquad \textbf{If} topicSubscribers == $\bot$ \textbf{Then}

\qquad \qquad \qquad topicSubscribers $\leftarrow$ \{\};

\qquad \qquad \qquad topicsWithSubscriptions[topic] $\leftarrow$ topicSubscribers;

\qquad \qquad \qquad topicSubscribersTTL $\leftarrow$ \{\};

\qquad \qquad \qquad subscriptionsTTL[topic] $\leftarrow$ topicSubscribersTTL;

\qquad \qquad topicSubscribers[originalNode.id] $\leftarrow$ topicSubscribers[originalNode.id] $\cup$ originalNode.node;

\qquad \qquad topicSubscribersTTL[originalNode.id] $\leftarrow$ topicSubscribersTTL[originalNode.id] $\cup$ currentSystemTime();

\qquad \textbf{Else If} msgType == UNSUBSCRIBE \textbf{Then}

\qquad \qquad topicSubscribers $\leftarrow$ topicsWithSubscriptions[topic];

\qquad \qquad topicSubscribersTTL $\leftarrow$ subscriptionsTTL[topic];

\qquad \qquad \textbf{If} topicSubscribers != $\bot$ \textbf{Then}

\qquad \qquad \qquad 
topicSubscribers $\leftarrow$ topicSubscribers $\setminus$ originalNode.id;

\qquad \qquad \qquad 
topicSubscribersTTL $\leftarrow$ topicSubscribersTTL $\setminus$ originalNode.id;

\qquad \textbf{Else If} msgType == PUBLISH \textbf{Then}

\qquad \qquad topicSubscribers $\leftarrow$ topicsWithSubscriptions[topic];


\qquad \qquad \textbf{Foreach} subscriber $\in$ topicSubscribers \textbf{do:}

\qquad \qquad \qquad \textbf{Trigger Send(MessageDelivery}, subscriber, topic, msg);

\bigbreak
\textbf{Upon Recieve(MessageDelivery}, sender, topic msg) \textbf{do:}

\qquad \textbf{Trigger SomeEventHandler}(topic, msg);

\bigbreak
\textbf{Upon RefreshMySubscriptions do:}

\qquad \textbf{Foreach} subscription $\in$ 
subscriptionsAlreadySent \textbf{do:}

\qquad \qquad topicId $\leftarrow$ intSHA1Hash(subscription.topic);

\qquad \qquad \textbf{Trigger Send(FindSuccessor}, self, topicId, self.node, subscription);

\bigbreak
\textbf{Upon CheckMyTopicsSubscribersTTL do:}

\qquad \textbf{Foreach} entry $\in$ subscriptionsTTL \textbf{do:}

\qquad \qquad \textbf{Foreach} subscriber $\in$ entry.subscribers \textbf{do:}

\qquad \qquad \qquad \textbf{If} (currentSystemTime() > subscriber.TTL + TTL) \textbf{Then}

\qquad \qquad \qquad \qquad subscriptionsTTL $\leftarrow$ subscriptionsTTL $\setminus$ {topic};

\qquad \qquad \qquad \qquad topicsWithSubscriptions $\leftarrow$ topicsWithSubscriptions $\setminus$ {topic};





\newpage
\section{Avaliação dos resultados}

Esta secção aborda as experiências que se realizaram, os resultados e conclusões das mesmas.

\subsection{Experiências}

As experiências foram realizadas num cenário perfeito, sem falhas nos nós, nem na rede.

A rede foi construída de forma local e não em várias máquinas.

Realizou-se duas experiências. Na primeira, fixou-se o número de nós em 100 e fez-se variar o número de publicações em 10, 50, 100, 500 e 1000. Na segunda, fixou-se o número de publicações em 10 e fez-se varias o número de nós em 10, 100, 500, 1000, 1750, 2500, 5000, 7500, 10000, 15000, 20000, 25000 e 50000.

\subsection{Resultados com observações}

Na primeira experiência, conclui-se que o número de publicações feita, não influencia a taxa de entrega das mesmas. Por muito grande que seja a quantidade de mensagens na rede, esta tem uma grande capacidade para lidar com a carga e conseguiu entregar todas as publicações, para uma rede de 100 nós.

Já na segunda experiência, os resultados foram diferentes. Apresenta-se em primeiro lugar o gráfico dos resultados recolhidos.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.9\textwidth]{grafico1.png}
	\caption{Taxa de entrega de mensagens com aumento do número de nós na rede.}
	\label{fig:graf1}
\end{figure}

Como se pode observar no Figura \ref{fig:graf1}, com o aumento do número de nós, existe um decréscimo da taxa de entrega das publicações. Recomenda-se a utilização do algoritmo para redes até 1000 nós, para obter-se uma taxa de pelo menos 90\%. Para 5000 nós obteve-se uma taxa de 50\%, o que já se considera de baixa eficiência.

\newpage
\section{Conclusão}

Neste trabalho foi possível estudar, as várias fases de construção de um sistema distribuído.

Numa primeira fase, não foi fácil a compreensão dos pormenores da implementação do sistema. O algoritmo de Chord é complexo e demorou tempo a perceber o seu funcionamento.

Nenhum dos membros do grupo tinha trabalhado com a linguagem de Scala, nem com a biblioteca do Akka, no entanto, decidiu-se aprender a utilizar as mesmas. Esta decisão foi acertada, pois apesar de ter demorado bastante tempo a aprender utilizar ambas, poupou-se muito tempo na implementação.

A implementação do algoritmo, foi relativamente fácil após a compreensão do mesmo. O mais difícil, foi a implementação do programa de teste.

Dos testes, concluiu-se que a eficácia da rede, não depende do número de publicações, mas sim do número de nós na rede.

O trabalho foi complexo, no entanto, foi interessante trabalhar, com a implementação de um sistema distribuído e estruturado. Os resultados também foram inesperados, pois esperava-se que com o aumento do número de mensagens, a rede se congestionasse, que não foi o caso.

\newpage
\begin{thebibliography}{00}
\bibitem{b1} Leitão, J. (2018). Materiais da cadeira de ASD. FCT/UNL.
\bibitem{b2} Stoica, I., Morris, R., Liben-Nowell, D., Karger, D. R., Kaashoek, M. F., Dabek, F., \& Balakrishnan, H. (2003). Chord: A scalable peer-to-peer lookup protocol for Internet applications. IEEE/ACM Transactions on Networking, 11(1), 17–32. https://doi.org/10.1109/TNET.2002.808407
\bibitem{b3} Fédérale, É. P., \& (EPFL), L. (n.d.). Scala. Retrieved November 17, 2018, from https://www.scala-lang.org/
\bibitem{b4} Lightbend, I. (n.d.). Akka. Retrieved November 17, 2018, from https://akka.io/
\bibitem{b5} Penman, T. (n.d.). Implementing a Distributed Hash Table with Scala and Akka. Retrieved November 17, 2018, from http://tristanpenman.com/blog/posts/2015/11/26/implementing-a-dht-with-scala-and-akka/
\end{thebibliography}

\end{document}